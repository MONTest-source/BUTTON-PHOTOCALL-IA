<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Captura y escanea el QR de forma f√°cil y r√°pida">
    <meta name="keywords" content="Photocall, QR, Captura, Escaneo, F√°cil, R√°pido">
    <meta name="MappingON" content="Photocall">
    <meta name="robots" content="index, follow">
    <meta name="googlebot" content="index, follow">
    <meta name="google" content="notranslate">
    <meta name="google" content="notranslate">
    <title>Photocall IA ‚Äì Captura y QR</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg?v=2">
    <link rel="shortcut icon" href="favicon.svg?v=2">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Anton&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="app-container">
        <!-- HEADER -->
        <header class="header" role="banner">
            <div class="logo-mon" aria-hidden="true">
                <img src="logo.png" alt="MON Mapping ON" class="logo-mon-img">
            </div>
            <div class="header-content">
                <h1>Photocall IA</h1>
                <p class="subtitle">Pulsa CAPTURAR, espera 10s y escanea el QR</p>
            </div>
        </header>

        <!-- MAIN CONTENT -->
        <main class="main-content" role="main">
            <div class="content-card">
                <!-- STATE: IDLE -->
                <div class="state-idle" id="state-idle" role="region" aria-label="Estado inicial">
                    <button class="btn-primary" id="capture-btn" aria-label="Iniciar captura de foto">
                        <div class="particles" id="particles-container"></div>
                        <div class="btn-content">
                            <div class="btn-text">CAPTURAR</div>
                            <div class="btn-icon" aria-hidden="true">üì∏</div>
                        </div>
                    </button>
                    <p class="note-text note-text-spaced" aria-live="polite">
                        La descarga se har√° mediante un c√≥digo QR.
                    </p>
                </div>

                <!-- STATE: COUNTDOWN (dentro del bot√≥n) -->
                <div class="state-countdown hidden" id="state-countdown" role="region" aria-label="Cuenta atr√°s">
                    <button class="btn-primary" disabled aria-label="Captura en progreso">
                        <div class="btn-content">
                            <div class="btn-countdown" id="countdown-display" 
                                 role="timer" 
                                 aria-live="assertive" 
                                 aria-atomic="true"
                                 aria-label="Cuenta atr√°s en segundos">
                                10
                            </div>
                            <p class="btn-message" id="countdown-message" aria-live="polite">
                                Mant√©n la pose, no te muevas, pronto se capturar√° tu foto‚Ä¶
                            </p>
                            <div class="loading-spinner" id="loading-spinner" role="status" aria-label="Cargando imagen">
                                <div class="spinner-ring"></div>
                                <div class="spinner-ring"></div>
                                <div class="spinner-ring"></div>
                            </div>
                        </div>
                    </button>
                </div>

                <!-- STATE: READY (dentro del bot√≥n) -->
                <div class="state-ready hidden" id="state-ready" role="region" aria-label="Foto lista">
                    <button class="btn-primary" disabled aria-label="QR listo">
                        <div class="btn-content">
                            <div class="btn-qr-title">¬°Tu foto est√° lista!</div>
                            <div class="btn-qr-container">
                                <img id="qr-code-img" 
                                     alt="C√≥digo QR para descargar tu foto. Escanea con tu m√≥vil para acceder a la descarga."
                                     role="img"
                                     aria-label="C√≥digo QR de descarga">
                            </div>
                            <p class="btn-message">
                                Escanea el QR para descargar tu foto.
                            </p>
                        </div>
                    </button>
                </div>

                <!-- STATE: ERROR -->
                <div class="state-error hidden" id="state-error" role="alert">
                    <div class="error-icon" aria-hidden="true">‚ö†Ô∏è</div>
                    <p class="error-message">
                        Ha ocurrido un error inesperado.
                    </p>
                    <button class="btn-primary" id="retry-btn" aria-label="Reintentar captura">
                        Reintentar
                    </button>
                </div>
            </div>
        </main>

        <!-- FOOTER -->
        <footer class="footer" role="contentinfo">
            <p class="footer-text">
                Tus datos no se almacenan m√°s all√° del evento. Solicita borrado si lo necesitas.
            </p>
        </footer>
    </div>

    <!-- TOAST CONTAINER -->
    <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

    <!-- Canvas para animaci√≥n de olas -->
    <canvas id="waves-canvas"></canvas>

    <!-- Elementos para animaci√≥n de reinicio -->
    <div class="reset-overlay" id="reset-overlay"></div>
    <div class="reset-circle" id="reset-circle"></div>
    <div class="reset-sweep" id="reset-sweep"></div>
    <div class="reset-message" id="reset-message">REINICIANDO...</div>

    <!-- QRCode Library -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js" 
            crossorigin="anonymous"
            onerror="window.QRCodeLoadFailed = true;"></script>

    <script>
        // ============================================
        // CONSTANTS & STATE
        // ============================================
        let countdownInterval = null;
        let resetTimeout = null;
        const COUNTDOWN_DURATION = 10; // 10 segundos
        const RESET_UI_TIMEOUT = 30000; // 30 segundos (30 minutos = 1800000)
        
        // WebSocket connection
        let wsConnection = null;
        // WebSocket URL - Se adapta autom√°ticamente a HTTP/HTTPS y ws/wss
        const WS_URL = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host;
        
        // ============================================
        // PERFORMANCE DETECTION & OPTIMIZATION
        // ============================================
        let performanceMode = 'normal'; // 'normal', 'reduced'
        
        // Detectar rendimiento del dispositivo
        function detectPerformanceMode() {
            // Detectar dispositivos m√≥viles o navegadores lentos
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
            const hasReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
            
            // Detectar FPS mediante prueba r√°pida
            let lastTime = performance.now();
            let frameCount = 0;
            let testFrames = 0;
            
            function testFPS() {
                frameCount++;
                testFrames++;
                
                if (testFrames >= 30) {
                    const fps = (frameCount / ((performance.now() - lastTime) / 1000));
                    if (fps < 30 || isMobile || isLowEnd || hasReducedMotion) {
                        performanceMode = 'reduced';
                        console.log('[Performance] Modo reducido activado (FPS:', fps.toFixed(1), ')');
                    }
                    return;
                }
                requestAnimationFrame(testFPS);
            }
            requestAnimationFrame(testFPS);
        }
        
        // Iniciar detecci√≥n de rendimiento
        detectPerformanceMode();

        // ============================================
        // DOM SELECTORS
        // ============================================
        const captureBtn = document.getElementById('capture-btn');
        const retryBtn = document.getElementById('retry-btn');
        const openLinkBtn = document.getElementById('open-link-btn');
        
        const stateIdle = document.getElementById('state-idle');
        const stateCountdown = document.getElementById('state-countdown');
        const stateReady = document.getElementById('state-ready');
        const stateError = document.getElementById('state-error');
        
        const countdownDisplay = document.getElementById('countdown-display');
        const countdownMessage = document.getElementById('countdown-message');
        const loadingSpinner = document.getElementById('loading-spinner');
        const qrCodeImg = document.getElementById('qr-code-img');
        const toastContainer = document.getElementById('toast-container');

        // ============================================
        // STATE MANAGEMENT
        // ============================================
        function showState(stateElement) {
            [stateIdle, stateCountdown, stateReady, stateError].forEach(el => {
                el.classList.add('hidden');
            });
            stateElement.classList.remove('hidden');
        }

        function resetUI() {
            // Activar animaci√≥n de reinicio antes de resetear
            playResetAnimation();
            
            // Esperar a que termine la animaci√≥n antes de resetear el UI
            setTimeout(() => {
                clearInterval(countdownInterval);
                clearTimeout(resetTimeout);
                countdownInterval = null;
                resetTimeout = null;
                if (countdownDisplay) {
                    countdownDisplay.textContent = '';
                    countdownDisplay.style.display = 'block';
                }
                if (countdownMessage) countdownMessage.textContent = '';
                if (loadingSpinner) {
                    loadingSpinner.classList.remove('active');
                }
                if (qrCodeImg) qrCodeImg.src = '';
                captureBtn.disabled = false;
                showState(stateIdle);
                
                // UI reseteada al estado inicial
            }, 600); // Esperar medio segundo para que la animaci√≥n se vea bien
        }

        // ============================================
        // ANIMACI√ìN DE REINICIO
        // ============================================
        function playResetAnimation() {
            const overlay = document.getElementById('reset-overlay');
            const circle = document.getElementById('reset-circle');
            const sweep = document.getElementById('reset-sweep');
            const message = document.getElementById('reset-message');
            
            // Activar todas las animaciones simult√°neamente
            if (overlay) {
                overlay.classList.remove('active');
                // Forzar reflow para reiniciar la animaci√≥n
                void overlay.offsetWidth;
                overlay.classList.add('active');
            }
            
            if (circle) {
                circle.classList.remove('active');
                void circle.offsetWidth;
                circle.classList.add('active');
            }
            
            if (sweep) {
                sweep.classList.remove('active');
                void sweep.offsetWidth;
                sweep.classList.add('active');
            }
            
            if (message) {
                message.classList.remove('active');
                void message.offsetWidth;
                message.classList.add('active');
            }
            
            // Dispersar murci√©lagos al reiniciar (efecto de "reset")
            if (wavesAnimation) {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                // Crear murci√©lagos que se dispersan en todas las direcciones
                wavesAnimation.triggerBats(centerX, centerY, 'high');
            }
            
            // Remover clases despu√©s de la animaci√≥n
            setTimeout(() => {
                if (overlay) overlay.classList.remove('active');
                if (circle) circle.classList.remove('active');
                if (sweep) sweep.classList.remove('active');
                if (message) message.classList.remove('active');
            }, 1200);
        }

        // ============================================
        // TOAST NOTIFICATIONS
        // ============================================
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.setAttribute('role', 'status');
            toast.setAttribute('aria-live', 'assertive');
            
            const icon = type === 'success' ? '‚úì' : '‚ö†';
            toast.innerHTML = `<span>${icon}</span><span>${message}</span>`;
            
            toastContainer.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideUp 0.3s ease reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ============================================
        // COUNTDOWN
        // ============================================
        function startCountdown(duration) {
            showState(stateCountdown);
            let timeLeft = duration;
            countdownDisplay.textContent = timeLeft;
            countdownDisplay.setAttribute('aria-label', `Cuenta atr√°s: ${timeLeft} segundos`);
            
            // Mostrar mensaje durante la cuenta atr√°s (momento de la captura)
            countdownMessage.textContent = 'Mant√©n la pose, no te muevas, pronto se capturar√° tu foto‚Ä¶';

            countdownInterval = setInterval(() => {
                timeLeft--;
                countdownDisplay.textContent = timeLeft;
                countdownDisplay.setAttribute('aria-label', `Cuenta atr√°s: ${timeLeft} segundos`);
                
                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    countdownInterval = null;
                    // Ocultar el n√∫mero y mostrar el spinner de carga
                    countdownDisplay.textContent = '';
                    countdownDisplay.style.display = 'none';
                    
                    // Mostrar spinner de carga
                    if (loadingSpinner) {
                        loadingSpinner.classList.add('active');
                    }
                    
                    // Mantener el mensaje visible por 10 segundos m√°s antes de mostrar QR
                    setTimeout(() => {
                        // Ocultar spinner antes de mostrar QR
                        if (loadingSpinner) {
                            loadingSpinner.classList.remove('active');
                        }
                        showQR();
                    }, 10000); // 10 segundos adicionales con el mensaje
                }
            }, 1000);
        }

        // ============================================
        // GENERATE AND SHOW QR
        // ============================================
        function showQR() {
            // Verificar que QRCode est√© disponible
            if (typeof QRCode === 'undefined' || window.QRCodeLoadFailed) {
                // Silenciosamente usar placeholder si QRCode no est√° disponible
                const placeholderQR = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgZmlsbD0iI2ZmZiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiMwMDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5RUiBQcm90b3R5cG88L3RleHQ+PC9zdmc+';
                qrCodeImg.src = placeholderQR;
                showState(stateReady);
                showToast('Tu foto est√° lista', 'success');
                
                // A√±adir animaci√≥n especial tambi√©n para placeholder
                const qrContainer = document.querySelector('.btn-qr-container');
                if (qrContainer) {
                    qrContainer.classList.add('qr-appearing');
                    for (let i = 0; i < 3; i++) {
                        setTimeout(() => {
                            const ripple = document.createElement('div');
                            ripple.className = 'qr-ripple';
                            ripple.style.animationDelay = `${i * 0.2}s`;
                            qrContainer.appendChild(ripple);
                            setTimeout(() => {
                                if (ripple.parentNode) ripple.remove();
                            }, 2000);
                        }, i * 200);
                    }
                    setTimeout(() => {
                        qrContainer.classList.remove('qr-appearing');
                    }, 2000);
                }
                
                // Murci√©lagos cuando aparece el QR placeholder
                if (wavesAnimation) {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    wavesAnimation.triggerBats(centerX, centerY, 'high');
                }
                
                resetTimeout = setTimeout(() => {
                    console.log("Reseteando aplicaci√≥n despu√©s de 30 segundos...");
                    resetUI();
                }, RESET_UI_TIMEOUT);
                return;
            }
            
            // Generar un ID √∫nico para esta sesi√≥n
            const sessionId = Date.now().toString(36) + Math.random().toString(36).substr(2);
            const redirectUrl = `${window.location.origin}/d/${sessionId}`;
            
            // Generar QR falso usando la librer√≠a QRCode
            try {
                    QRCode.toDataURL(redirectUrl, {
                        width: 160,
                        margin: 1,
                        color: {
                            dark: '#000000',
                            light: '#FFFFFF'
                        },
                        errorCorrectionLevel: 'H'
                    }, (err, qrDataUrl) => {
                    if (err) {
                        // Silenciosamente usar placeholder si falla la generaci√≥n
                        // Usar placeholder si falla
                        const placeholderQR = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgZmlsbD0iI2ZmZiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiMwMDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5RUiBQcm90b3R5cG88L3RleHQ+PC9zdmc+';
                        qrCodeImg.src = placeholderQR;
                        showState(stateReady);
                        showToast('Tu foto est√° lista', 'success');
                        
                        // A√±adir animaci√≥n especial tambi√©n para error
                        const qrContainer = document.querySelector('.btn-qr-container');
                        if (qrContainer) {
                            qrContainer.classList.add('qr-appearing');
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    const ripple = document.createElement('div');
                                    ripple.className = 'qr-ripple';
                                    ripple.style.animationDelay = `${i * 0.2}s`;
                                    qrContainer.appendChild(ripple);
                                    setTimeout(() => {
                                        if (ripple.parentNode) ripple.remove();
                                    }, 2000);
                                }, i * 200);
                            }
                            setTimeout(() => {
                                qrContainer.classList.remove('qr-appearing');
                            }, 2000);
                        }
                        
                        // Murci√©lagos cuando aparece el QR de error
                        if (wavesAnimation) {
                            const centerX = window.innerWidth / 2;
                            const centerY = window.innerHeight / 2;
                            wavesAnimation.triggerBats(centerX, centerY, 'high');
                        }
                        
                        resetTimeout = setTimeout(() => {
                            resetUI();
                        }, RESET_UI_TIMEOUT);
                        return;
                    }
                    
                    // Mostrar el QR dentro del bot√≥n
                    qrCodeImg.onload = () => {
                        showState(stateReady);
                        showToast('Tu foto est√° lista', 'success');
                        
                        // Obtener el contenedor del QR
                        const qrContainer = document.querySelector('.btn-qr-container');
                        
                        // A√±adir animaci√≥n especial cuando aparece el QR
                        if (qrContainer) {
                            // A√±adir clase de animaci√≥n
                            qrContainer.classList.add('qr-appearing');
                            
                            // Crear ondas conc√©ntricas m√∫ltiples
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    const ripple = document.createElement('div');
                                    ripple.className = 'qr-ripple';
                                    ripple.style.animationDelay = `${i * 0.2}s`;
                                    qrContainer.appendChild(ripple);
                                    
                                    // Remover despu√©s de la animaci√≥n
                                    setTimeout(() => {
                                        if (ripple.parentNode) {
                                            ripple.remove();
                                        }
                                    }, 2000);
                                }, i * 200);
                            }
                            
                            // Remover clase de animaci√≥n despu√©s de completarse
                            setTimeout(() => {
                                qrContainer.classList.remove('qr-appearing');
                            }, 2000);
                        }
                        
                        // Murci√©lagos cuando aparece el QR
                        if (wavesAnimation) {
                            const centerX = window.innerWidth / 2;
                            const centerY = window.innerHeight / 2;
                            wavesAnimation.triggerBats(centerX, centerY, 'high');
                        }
                        
                        // Anunciar para lectores de pantalla
                        const announcement = document.createElement('div');
                        announcement.className = 'sr-only';
                        announcement.setAttribute('role', 'status');
                        announcement.setAttribute('aria-live', 'assertive');
                        announcement.textContent = 'Tu foto est√° lista. Escanea el c√≥digo QR para descargarla.';
                        document.body.appendChild(announcement);
                        setTimeout(() => announcement.remove(), 1000);
                    };
                    
                    qrCodeImg.onerror = () => {
                        // Silenciosamente usar placeholder si falla la carga
                        const placeholderQR = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgZmlsbD0iI2ZmZiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiMwMDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5RUiBQcm90b3R5cG88L3RleHQ+PC9zdmc+';
                        qrCodeImg.src = placeholderQR;
                        showState(stateReady);
                    };
                    
                    qrCodeImg.src = qrDataUrl;
                    
                    // Programar reseteo despu√©s de 30 segundos
                    resetTimeout = setTimeout(() => {
                        resetUI();
                    }, RESET_UI_TIMEOUT);
                });
            } catch (error) {
                // Silenciosamente usar placeholder si hay error
                const placeholderQR = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMjgwIiBoZWlnaHQ9IjI4MCIgZmlsbD0iI2ZmZiIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjQiIGZpbGw9IiMwMDAiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5RUiBQcm90b3R5cG88L3RleHQ+PC9zdmc+';
                qrCodeImg.src = placeholderQR;
                showState(stateReady);
                showToast('Tu foto est√° lista', 'success');
                
                // A√±adir animaci√≥n especial
                const qrContainer = document.querySelector('.btn-qr-container');
                if (qrContainer) {
                    qrContainer.classList.add('qr-appearing');
                    setTimeout(() => qrContainer.classList.remove('qr-appearing'), 2000);
                }
                
                resetTimeout = setTimeout(() => {
                    resetUI();
                }, RESET_UI_TIMEOUT);
            }
        }

        // ============================================
        // ERROR HANDLING
        // ============================================
        function showError(message) {
            showState(stateError);
            showToast(message, 'error');
        }

        // ============================================
        // WEBSOCKET CONNECTION
        // ============================================
        let wsReconnectAttempts = 0;
        const MAX_WS_RECONNECT_ATTEMPTS = 3;
        let wsReconnectTimeout = null;

        function connectWebSocket() {
            // No intentar conectar si ya hay demasiados intentos fallidos
            if (wsReconnectAttempts >= MAX_WS_RECONNECT_ATTEMPTS) {
                return; // Silenciosamente dejar de intentar
            }

            try {
                wsConnection = new WebSocket(WS_URL);
                
                wsConnection.onopen = () => {
                    console.log('[WebSocket] Conectado al servidor');
                    wsReconnectAttempts = 0; // Resetear contador al conectar exitosamente
                };
                
                wsConnection.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        // Solo loggear mensajes importantes
                        if (data.type === 'connected') {
                            console.log('[WebSocket] Conectado:', data.message);
                        }
                    } catch (error) {
                        // Silenciosamente manejar errores de parsing
                    }
                };
                
                wsConnection.onerror = (error) => {
                    // No loggear errores de WebSocket si el servidor no est√° disponible
                    // Esto es normal cuando se usa el modo prototipo sin backend
                    wsReconnectAttempts++;
                };
                
                wsConnection.onclose = () => {
                    // Solo intentar reconectar si no hemos excedido el l√≠mite
                    if (wsReconnectAttempts < MAX_WS_RECONNECT_ATTEMPTS) {
                        wsReconnectTimeout = setTimeout(() => {
                            connectWebSocket();
                        }, 3000);
                    }
                    // Si excedimos el l√≠mite, silenciosamente dejar de intentar
                };
            } catch (error) {
                // Silenciosamente manejar errores de creaci√≥n de WebSocket
                wsReconnectAttempts++;
            }
        }
        
        function sendWebSocketMessage(message) {
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                try {
                    wsConnection.send(JSON.stringify(message));
                    return true;
                } catch (error) {
                    return false;
                }
            }
            return false; // Silenciosamente fallar si no hay conexi√≥n
        }

        // ============================================
        // CAPTURE HANDLER
        // ============================================
        function handleCaptureClick() {
            if (captureBtn.disabled) return;
            
            captureBtn.disabled = true;
            // Iniciando captura
            
            // Trigger murci√©lagos desde el bot√≥n (MUCHOS al hacer click)
            if (wavesAnimation) {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                wavesAnimation.triggerBats(centerX, centerY, 'high');
            }
            
            // Enviar mensaje WebSocket a TouchDesigner
            const captureMessage = {
                type: 'capture',
                timestamp: Date.now(),
                countdownSec: COUNTDOWN_DURATION
            };
            
            // Intentar enviar por WebSocket, si falla el backend lo manejar√° v√≠a POST
            sendWebSocketMessage(captureMessage);
            
            // Tambi√©n hacer POST /api/capture para crear el jobId
            // (El backend tambi√©n enviar√° el mensaje WebSocket, pero es redundante si ya lo enviamos aqu√≠)
            // Por ahora mantenemos el POST para mantener compatibilidad
            fetch('/api/capture', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                // Job creado exitosamente
            })
            .catch(error => {
                // Silenciosamente manejar errores de red (normal en modo prototipo)
            });
            
            // Iniciar cuenta atr√°s de 10 segundos directamente
            startCountdown(COUNTDOWN_DURATION);
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================
        captureBtn.addEventListener('click', handleCaptureClick);
        retryBtn.addEventListener('click', () => {
            resetUI();
            setTimeout(() => handleCaptureClick(), 100);
        });

        // Keyboard support
        captureBtn.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleCaptureClick();
            }
        });

        // ============================================
        // WAVES ANIMATION
        // ============================================
        class WavesAnimation {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.waves = [];
                this.bats = [];
                this.animationId = null;
                this.lastFrameTime = 0;
                this.frameSkip = 0; // Para reducir frames en modo reducido
                
                // Forma del murci√©lago extra√≠da del JSON Lottie (puntos del path)
                this.batShape = [
                    [-70.0, 0.0],
                    [-55.0, -20.0],
                    [-40.0, -25.0],
                    [-20.0, -15.0],
                    [-10.0, -5.0],
                    [-5.0, -20.0],
                    [0.0, -35.0],
                    [5.0, -20.0],
                    [10.0, -5.0],
                    [20.0, -15.0],
                    [40.0, -25.0],
                    [55.0, -20.0],
                    [70.0, 0.0],
                    [50.0, 10.0],
                    [30.0, 25.0],
                    [10.0, 30.0],
                    [0.0, 20.0],
                    [-10.0, 30.0],
                    [-30.0, 25.0],
                    [-50.0, 10.0]
                ];
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Crear olas iniciales
                this.createWaves();
                this.animate();
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                // Recrear olas con nuevas posiciones basadas en el nuevo tama√±o
                this.createWaves();
            }
            
            createWaves() {
                // OPTIMIZACI√ìN: Reducir n√∫mero de olas en modo reducido
                const waveCount = performanceMode === 'reduced' ? 2 : 4;
                
                // Olas con perspectiva 3D (vista desde arriba)
                const allWaves = [
                    {
                        centerX: this.canvas.width * 0.3,
                        centerY: this.canvas.height * 0.3,
                        radius: 150,
                        amplitude: 25,
                        frequency: 0.02,
                        speed: 0.015,
                        phase: 0,
                        color: 'rgba(0, 224, 255, 0.25)',
                        depth: 0.8
                    },
                    {
                        centerX: this.canvas.width * 0.7,
                        centerY: this.canvas.height * 0.5,
                        radius: 180,
                        amplitude: 30,
                        frequency: 0.018,
                        speed: 0.012,
                        phase: Math.PI / 3,
                        color: 'rgba(0, 224, 255, 0.2)',
                        depth: 0.7
                    },
                    {
                        centerX: this.canvas.width * 0.5,
                        centerY: this.canvas.height * 0.7,
                        radius: 200,
                        amplitude: 35,
                        frequency: 0.015,
                        speed: 0.01,
                        phase: Math.PI / 2,
                        color: 'rgba(0, 224, 255, 0.15)',
                        depth: 0.6
                    },
                    {
                        centerX: this.canvas.width * 0.2,
                        centerY: this.canvas.height * 0.8,
                        radius: 120,
                        amplitude: 20,
                        frequency: 0.022,
                        speed: 0.018,
                        phase: Math.PI,
                        color: 'rgba(0, 224, 255, 0.12)',
                        depth: 0.9
                    }
                ];
                
                this.waves = allWaves.slice(0, waveCount);
            }
            
            addBat(startX, startY, count = 1) {
                // OPTIMIZACI√ìN: Reducir l√≠mite de murci√©lagos (de 50 a 35)
                if (this.bats.length > 35) {
                    return; // No agregar m√°s si ya hay muchos
                }
                
                // Crear m√∫ltiples murci√©lagos con trayectorias mejoradas y naturales
                for (let i = 0; i < count; i++) {
                    // √Ångulo base con variaci√≥n para crear efecto de enjambre
                    const baseAngle = Math.random() * Math.PI * 2;
                    const speed = 3 + Math.random() * 4; // Velocidad m√°s variada
                    const maxDistance = Math.max(this.canvas.width, this.canvas.height) * 1.5;
                    const offsetAngle = (Math.PI * 2 / count) * i;
                    const spreadRadius = 30; // Radio de dispersi√≥n inicial
                    
                    // Trayectoria con curva natural (vuelo m√°s realista)
                    const curveAmount = 0.3 + Math.random() * 0.4; // Cantidad de curva
                    const curveDirection = Math.random() > 0.5 ? 1 : -1;
                    
                    // Velocidad inicial con componente de curva
                    let vx = Math.cos(baseAngle) * speed;
                    let vy = Math.sin(baseAngle) * speed;
                    
                    // A√±adir componente de curva para vuelo m√°s natural
                    const perpendicularAngle = baseAngle + (Math.PI / 2) * curveDirection;
                    vx += Math.cos(perpendicularAngle) * speed * curveAmount * 0.3;
                    vy += Math.sin(perpendicularAngle) * speed * curveAmount * 0.3;
                    
                    // √Ångulo inicial basado en direcci√≥n de movimiento
                    const rotationAngle = Math.atan2(vy, vx);
                    
                    this.bats.push({
                        x: startX + Math.cos(offsetAngle) * spreadRadius,
                        y: startY + Math.sin(offsetAngle) * spreadRadius,
                        vx: vx,
                        vy: vy,
                        angle: rotationAngle,
                        distance: 0,
                        maxDistance: maxDistance,
                        size: 20 + Math.random() * 12, // Tama√±o m√°s variado
                        opacity: 1,
                        wingPhase: Math.random() * Math.PI * 2,
                        wingSpeed: 0.3 + Math.random() * 0.25, // Animaci√≥n de alas m√°s r√°pida
                        glow: 0.85 + Math.random() * 0.15, // Glow m√°s variado
                        color: `rgba(0, 224, 255, 1)`,
                        curveAmount: curveAmount, // Guardar para aplicar curva continua
                        curveDirection: curveDirection
                    });
                }
            }
            
            drawWave(wave) {
                // OPTIMIZACI√ìN: Reducir segmentos para mejor rendimiento (de 64 a 32)
                const segments = 32;
                
                // OPTIMIZACI√ìN: Reducir n√∫mero de anillos conc√©ntricos (de 3 a 2)
                for (let ring = 0; ring < 2; ring++) {
                    const ringRadius = wave.radius - (ring * 25);
                    const ringAmplitude = wave.amplitude * (1 - ring * 0.3);
                    
                    this.ctx.beginPath();
                    
                    // OPTIMIZACI√ìN: Calcular solo los puntos necesarios
                    for (let i = 0; i <= segments; i++) {
                        const angle = (Math.PI * 2 / segments) * i;
                        const height = Math.sin((angle * wave.frequency * 10) + wave.phase) * ringAmplitude;
                        const x = wave.centerX + Math.cos(angle) * ringRadius;
                        const y = wave.centerY + Math.sin(angle) * ringRadius + (height * wave.depth);
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.closePath();
                    
                    // OPTIMIZACI√ìN: Usar fillStyle simple en lugar de gradiente complejo
                    const opacityMatch = wave.color.match(/rgba?\([^)]+,\s*([\d.]+)\)/);
                    const baseOpacity = opacityMatch ? parseFloat(opacityMatch[1]) : 0.2;
                    const ringOpacity = baseOpacity * (1 - ring * 0.25);
                    this.ctx.fillStyle = `rgba(0, 224, 255, ${ringOpacity * 0.6})`;
                    this.ctx.fill();
                }
                
                // OPTIMIZACI√ìN: Dibujar contorno solo si es necesario (reducir complejidad)
                if (this.bats.length === 0) { // Solo dibujar contorno cuando no hay murci√©lagos
                this.ctx.beginPath();
                    for (let i = 0; i <= segments; i += 2) { // Saltar puntos para reducir c√°lculos
                    const angle = (Math.PI * 2 / segments) * i;
                    const height = Math.sin((angle * wave.frequency * 10) + wave.phase) * wave.amplitude;
                    const x = wave.centerX + Math.cos(angle) * wave.radius;
                    const y = wave.centerY + Math.sin(angle) * wave.radius + (height * wave.depth);
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.closePath();
                this.ctx.strokeStyle = wave.color;
                this.ctx.lineWidth = 1;
                this.ctx.stroke();
                }
            }
            
            // OPTIMIZACI√ìN: Separar actualizaci√≥n de f√≠sica del dibujado
            updateBat(bat) {
                // Simplificar f√≠sica de curva (menos c√°lculos)
                if (bat.curveAmount !== undefined && Math.floor(bat.distance) % 5 === 0) {
                    const perpendicularAngle = Math.atan2(bat.vy, bat.vx) + (Math.PI / 2) * bat.curveDirection;
                    const curveForce = bat.curveAmount * 0.1;
                    bat.vx += Math.cos(perpendicularAngle) * curveForce;
                    bat.vy += Math.sin(perpendicularAngle) * curveForce;
                }
                
                // Actualizar posici√≥n y animaci√≥n de alas
                bat.x += bat.vx;
                bat.y += bat.vy;
                bat.distance += Math.abs(bat.vx) + Math.abs(bat.vy);
                bat.wingPhase += bat.wingSpeed;
                
                // Rotaci√≥n simplificada
                const targetAngle = Math.atan2(bat.vy, bat.vx);
                let angleDiff = targetAngle - bat.angle;
                if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                else if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                bat.angle += angleDiff * 0.2;
                
                // Reducir opacidad con la distancia
                bat.opacity = Math.max(0, 1 - (bat.distance / bat.maxDistance));
                
                // Retornar si debe eliminarse
                return bat.distance <= bat.maxDistance && bat.opacity >= 0.02;
                }
                
            drawBat(bat) {
                // OPTIMIZACI√ìN CR√çTICA: Eliminar shadowBlur completamente (muy costoso)
                // En su lugar, usar stroke m√°s grueso y m√∫ltiples capas simples
                
                this.ctx.save();
                this.ctx.globalAlpha = bat.opacity;
                
                // Dibujar murci√©lago
                this.ctx.translate(bat.x, bat.y);
                this.ctx.rotate(bat.angle);
                
                const scale = bat.size / 140;
                
                // Animaci√≥n de alas
                const wingSpread = Math.sin(bat.wingPhase) * 0.3 + 0.7;
                const wingScaleY = wingSpread;
                
                // OPTIMIZACI√ìN: Path simplificado - usar solo puntos clave (reducir de 20 a 8-10 puntos)
                this.ctx.beginPath();
                const points = this.batShape;
                // Usar solo puntos clave: inicio, picos superiores, centro, picos inferiores, fin
                const keyPoints = [0, 2, 6, 10, 12, 14, 16, 18]; // √çndices de puntos clave
                this.ctx.moveTo(points[keyPoints[0]][0] * scale, points[keyPoints[0]][1] * scale * wingScaleY);
                
                for (let i = 1; i < keyPoints.length; i++) {
                    const idx = keyPoints[i];
                    const [x, y] = points[idx];
                    this.ctx.lineTo(x * scale, y * scale * wingScaleY);
                }
                this.ctx.closePath();
                
                // OPTIMIZACI√ìN: Glow simplificado sin shadowBlur - usar stroke m√°s grueso y opacidad
                const glowOpacity = bat.opacity * bat.glow * 0.5;
                
                // Dibujar glow exterior (stroke m√°s grueso)
                this.ctx.strokeStyle = `rgba(0, 224, 255, ${glowOpacity * 0.3})`;
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Dibujar cuerpo principal
                this.ctx.fillStyle = '#000000';
                this.ctx.fill();
                
                // Dibujar contorno brillante
                this.ctx.strokeStyle = `rgba(0, 224, 255, ${bat.opacity * 0.8})`;
                this.ctx.lineWidth = 1.5;
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            drawBats() {
                // OPTIMIZACI√ìN: Reducir l√≠mite (de 50 a 35 para mejor rendimiento)
                if (this.bats.length > 35) {
                    this.bats = this.bats.slice(-35);
                }
                
                // OPTIMIZACI√ìN CR√çTICA: Separar actualizaci√≥n de f√≠sica del dibujado
                // Esto evita que filter() llame drawBat() dos veces (una para verificar, otra para dibujar)
                const aliveBats = [];
                for (let i = 0; i < this.bats.length; i++) {
                    const bat = this.bats[i];
                    if (this.updateBat(bat)) {
                        aliveBats.push(bat);
                        this.drawBat(bat);
                    }
                }
                this.bats = aliveBats;
            }
            
            animate() {
                const now = performance.now();
                
                // OPTIMIZACI√ìN: Saltar frames cuando hay murci√©lagos activos (mayor carga)
                if (this.bats.length > 0) {
                    // Si hay murci√©lagos, reducir FPS a la mitad para mejor rendimiento
                    this.frameSkip++;
                    if (this.frameSkip % 2 === 0) {
                        this.animationId = requestAnimationFrame(() => this.animate());
                        return;
                    }
                } else if (performanceMode === 'reduced') {
                    // Si no hay murci√©lagos pero estamos en modo reducido, mantener frame skipping
                    this.frameSkip++;
                    if (this.frameSkip % 2 === 0) {
                        this.animationId = requestAnimationFrame(() => this.animate());
                        return;
                    }
                }
                
                // Limpiar canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ANIMACI√ìN DE OLAS (independiente, siempre activa)
                this.waves.forEach(wave => {
                    wave.phase += wave.speed;
                    this.drawWave(wave);
                });
                
                // ANIMACI√ìN DE MURCI√âLAGOS (independiente, solo cuando hay)
                if (this.bats.length > 0) {
                    this.drawBats();
                }
                
                this.lastFrameTime = now;
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            triggerBats(x, y, intensity = 'normal') {
                // Usar las coordenadas proporcionadas o el centro del canvas como fallback
                const startX = x !== undefined ? x : this.canvas.width / 2;
                const startY = y !== undefined ? y : this.canvas.height / 2;
                
                // OPTIMIZACI√ìN: Reducir n√∫mero de murci√©lagos a√∫n m√°s (de 10/18 a 8/12)
                let batCount = 8;
                if (intensity === 'high') batCount = 12;
                
                // Generar murci√©lagos en r√°fagas escalonadas para efecto de enjambre
                for (let i = 0; i < batCount; i++) {
                    setTimeout(() => {
                        // Crear grupos de 2-4 murci√©lagos a la vez
                        const groupSize = 2 + Math.floor(Math.random() * 3);
                        this.addBat(startX, startY, groupSize);
                    }, i * 40);
                }
                
                // NO modificar las olas - animaciones independientes
            }
        }
        
        let wavesAnimation;

        // ============================================
        // CURSOR TRACKING & PARTICLE EFFECTS
        // ============================================
        function setupButtonCursorTracking(button) {
            const particlesContainer = button.querySelector('.particles');
            if (!particlesContainer) return;
            
            let mouseX = 0;
            let mouseY = 0;
            let isInside = false;
            let particleInterval = null;
            
            // Obtener el pseudo-elemento ::before para mover la luz
            const style = window.getComputedStyle(button, '::before');
            
            // Actualizar posici√≥n de la luz seg√∫n el cursor
            function updateLightPosition(e) {
                const rect = button.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                mouseX = x;
                mouseY = y;
                
                // Actualizar posici√≥n del ::before usando CSS custom properties
                button.style.setProperty('--cursor-x', `${x}px`);
                button.style.setProperty('--cursor-y', `${y}px`);
            }
            
            // Crear part√≠cula desde el cursor
            function createParticleFromCursor(x, y) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // Posici√≥n inicial (donde est√° el cursor)
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                // Direcci√≥n aleatoria desde el cursor
                const angle = Math.random() * Math.PI * 2;
                const distance = 30 + Math.random() * 50;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                
                particlesContainer.appendChild(particle);
                
                // Remover despu√©s de la animaci√≥n
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.remove();
                    }
                }, 1500);
            }
            
            // Crear part√≠culas desde el punto de clic/touch
            function createClickParticles(x, y) {
                // OPTIMIZACI√ìN: Reducir n√∫mero de part√≠culas (de 12 a 8)
                const particleCount = 8;
                
                // Crear efecto de ondas
                const ripple = document.createElement('div');
                ripple.className = 'click-ripple';
                ripple.style.left = `${x}px`;
                ripple.style.top = `${y}px`;
                button.appendChild(ripple);
                
                setTimeout(() => {
                    if (ripple.parentNode) {
                        ripple.remove();
                    }
                }, 600);
                
                // Crear m√∫ltiples part√≠culas desde el punto de clic
                for (let i = 0; i < particleCount; i++) {
                    setTimeout(() => {
                        createParticleFromCursor(x, y);
                    }, i * 30);
                }
            }
            
            // Mouse move - seguir cursor
            button.addEventListener('mousemove', (e) => {
                updateLightPosition(e);
                isInside = true;
            });
            
            // Mouse enter
            button.addEventListener('mouseenter', (e) => {
                isInside = true;
                updateLightPosition(e);
                
                // OPTIMIZACI√ìN: Reducir frecuencia de part√≠culas (de 150ms a 250ms)
                particleInterval = setInterval(() => {
                    if (isInside && !button.disabled) {
                        // OPTIMIZACI√ìN: Limitar n√∫mero m√°ximo de part√≠culas activas
                        const activeParticles = particlesContainer.querySelectorAll('.particle');
                        if (activeParticles.length < 15) { // M√°ximo 15 part√≠culas activas
                        createParticleFromCursor(mouseX, mouseY);
                    }
                    }
                }, 250); // Cada 250ms (m√°s lento = menos carga)
            });
            
            // Mouse leave
            button.addEventListener('mouseleave', () => {
                isInside = false;
                if (particleInterval) {
                    clearInterval(particleInterval);
                    particleInterval = null;
                }
            });
            
            // Click/Touch - crear part√≠culas desde el punto de contacto
            button.addEventListener('click', (e) => {
                const rect = button.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                createClickParticles(x, y);
            });
            
            // Touch support
            button.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                const rect = button.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                updateLightPosition({ clientX: touch.clientX, clientY: touch.clientY });
                createClickParticles(x, y);
            });
            
            button.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                updateLightPosition({ clientX: touch.clientX, clientY: touch.clientY });
            });
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        showState(stateIdle);
        
        // Conectar WebSocket al servidor
        connectWebSocket();
        
        // Inicializar animaci√≥n de olas
        const wavesCanvas = document.getElementById('waves-canvas');
        if (wavesCanvas) {
            wavesAnimation = new WavesAnimation(wavesCanvas);
        }
        
        // Configurar seguimiento de cursor y part√≠culas en todos los botones
        const allButtons = document.querySelectorAll('.btn-primary');
        allButtons.forEach(button => {
            setupButtonCursorTracking(button);
        });

        // Verificar que QRCode est√© cargado (solo en modo desarrollo)
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            window.addEventListener('load', () => {
                if (typeof QRCode === 'undefined' || window.QRCodeLoadFailed) {
                    console.info('QRCode library no disponible - usando placeholder (esto es normal en modo prototipo)');
                }
            });
        }

        // Cleanup on page hide
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Mantener intervalos activos para que el proceso contin√∫e
            }
        });
    </script>
</body>
</html>
